Applicazioni da installare:
WeKan
Claper

pw VM: morrolinux

LEGGERE FILE AZZERATI
CORSO KERNEL HACKING

tutto quello che avresti voluto sapere ma che non hai mai chiesto: morrolinux

Linux espone HW, API e configurazioni interne come fossero dei file

comando watch: lanciare il successivo comando ogni n secondi -> watch -n tempo comando (watch -n 0.1 cat /proc/interrupts)
l'input da tastiera viene preso in input dall' i8042

La CPU, tramite kernel, riesce a mettersi in comunicazione con una periferica.
Quando colleghiamo la periferica gli viene dato un range di indirizzi di memoria(virtuale) e per comunicare con la CPU deve generare degli interrupt.

cat /etc/passwd -> sudo cat /etc/shadow

INSERIMENTO PERIFERICA->INTERRUPT->CARICAMENTO DRIVER->un daemon in /dev/ crea un altro dispositivo/file per rappresentare la nuova periferica appena inserita

Per clonare chiavetta bit per bit a livello fisico e inserire tutto in un file: 
----------------------

LEZIONE 1:

System architecture:

Interrupt: segnale di sistema di interruzione verso la CPU per mettere in pratica un compito più importante.
Sono mappati verso le periferiche.
Ogni volta che premiamo un tasto viene inviato un interrupt perché cosi la CPU possa capire che comando è stato premuto e la relativa risposta in output.
Se questo interrupt è frequente può mandare in stallo la CPU.

cat /proc/interrupts: 
la cartella "proc" contiene una completa struttura interna del pc, è una struttura che descrive anche i processi, contiene il numero di INTERRUPTS
Contiene cosa ha originato l'interrupt, tipologia di interrupt e periferica che l'ha generato + i core fisici che hanno intercettato gli interrupt

sudo cat /proc/ioports: necessita di permessi di amministratore, altriment ho tutti indirizzi di memoria pari a 0, assegnati durante la fase di boot

cat /proc/dma: Direct Access Memory -> sudo /proc/iomem: mapping DMA; cat /proc/meminfo

Dispositivi cold-plug: RAM, CPU, scheda video: collegata alla porta PCI
Dispositivi hot-plug: collegati direttamente alla ports Universal Serial Bus

comando -> ls + tab + tab

lscpu: informazioni sulla cpu
CPU: esegue le operazioni aritmetiche basilari, facendo elaborazioni attraverso la somma (anche di un numero negativo).
All'interno ci sono dei circuiti/transistor, configurati per eseguire delle operazioni più complesse (cpu x86 di tipo CISC) che eseguono molti calcoli complessi nel giro di un clock.

lspci: elenca le periferiche PCI esterne collegate

lsusb: elenca le periferiche USB collegate; restituisce un ID associato alla periferica con alcune sue caratteristiche
lsusb -v/lsusb -t: informazioni aggiuntive

lsmod: elenca i moduli kernel caricati (il modulo kernel è un driver a tutti gli effetti)
I dettagli che vengono emessi in output sono: modulo, dimensione modulo si file system, quante istanza sono attive e quali moduli vengono richiamati (numero di volte che il modulo è stato caricato, siccome le GPU sono multi-threading) -> quanti thread, potenzialmente eseguite in parallelo, hanno richiamato quel modulo
Questi moduli vengono richiamati essendo i driver GENERICI, aventi bisogno di ulteriori implementazioni di dettaglio (comandi specifici) per svolgere determinate mansioni.

Possiamo tramite terminale scollegare un driver e di conseguenza disabilitare la periferica che necessitava di quel driver
Se c'è un malfunzionamento della periferica posso scollegare il driver della periferica che non funziona;
questo metodo può essere usato in un server, per evitare molto downtime.

lsmod | grep "pcspkr": 
modinfo pcspkr 
blacklist driver: quando riavvio non tornano attivi (quando disabilito un driver e riavvio torna attivo una volta riacceso)

COMANDO PER METTERE IN ORDINE CRESCENTE/DECRESCENTE I RISULTATI:
lsmod | sort -k3 -n (k = numero colonna)

DOVE SONO PRESENTI QUESTI DRIVER?
Sono presenti in modinfo -> restituisce filename (se lo elimino, cancello il driver)

sudo rmmod pcspkr -> disattivare/togliere modulo
sudo modprobe pcspkr -> attivare/inserire modulo

----
D-BUS: mezzo di comunicazione tra le applicazioni
System Bus per applicazioni di sistema, applicazioni di basso livello o che richiedono i privilegi di root
----

BIOS (Basic Input Output System): inizializza periferiche e lancia l'eseguibile del boot loader che si aspetta di trovare nei primi 512 B (MBR)
UEFI (Unified Extensible Firmware Interface): sistema operativo a parte, eseguisce eseguibili (se metto in una partizione fat32 un eseguibile .efi, (giochi o boot loader), riesce ad eseguirli.
é flessibile, quindi non si è limitati ai prim 512 B, quindi esegue ogni tipo di file eseguibile (tipo nella fase di dual boot dove scelgo l'OS)
Esegue solo se c'è presente il flag di default.
NVRAM (Not Volatile Random Access Memory): chip fisico con pochi KB di memoria contente preferenze di boot


systemctl: prefisso per comandi che hanno a che fare con sistema di init system, per poter dirgli con che runlevel avviarsi o qual'è il livello di default di avvio
sytemctl get-default
systemctl set-default


man systemd
boot.target: unità di systemd, servono per frazionare l'avvio
boot.service: definire cos'è un servizio
boot.timer: 
boot.device.mount: 
boot.socker: 


RECOVERY E DIAGNOSTICA BOOT:
